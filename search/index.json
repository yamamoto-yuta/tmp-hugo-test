[{"content":"Slack の Slash Commands を作成した際に色々つまづいたのでメモに残す。\n今回のゴール /echo で echo と返すスラッシュコマンドを作成する /hoge で hoge と返すスラッシュコマンドを作成する ngrok のセットアップ ダウンロードページの URL : https://ngrok.com/download\nアカウントを作成せずに利用していたが、次のエラーが出たのでアカウントを作成した:\n1 2 3 4 ERR_NGROK_6022 Before you can serve HTML content, you must sign up for an ngrok account and install your authtoken. https://ngrok.com/docs/errors/err_ngrok_6022/ 次のコマンドで ngrok を起動させる（今回は 3000 番ポートを使うことにする）:\n1 $ ngrok http 3000 各種ファイルの作成 .env.sample :\n1 2 3 4 WORKING_DIR=/usr/src/app OPENAI_API_KEY=# Your OpenAI API key SLACK_BOT_TOKEN=# OAuth \u0026amp; Permissions \u0026gt; OAuth Tokens for Your Workspace \u0026gt; Bot User OAuth Access Token SLACK_SIGNING_SECRET=# Basic Information \u0026gt; App Credentials \u0026gt; Signing Secret Dockerfile :\n1 2 3 4 5 6 7 8 FROM python:3.10 COPY requirements.txt ${WORKING_DIR}/ RUN apt-get update \u0026amp;\u0026amp; apt-get upgrade -y RUN pip install --upgrade pip \u0026amp;\u0026amp; \\ pip install -r requirements.txt docker-compose.yml :\n1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#34;3.7\u0026#34; services: app: build: . env_file: - .env volumes: - .:$WORKING_DIR working_dir: $WORKING_DIR tty: true ports: - 3000:3000 requirements.txt :\n1 slack_bolt==1.18.1 main.py :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import os from slack_bolt import App app = App( signing_secret=os.environ[\u0026#34;SLACK_SIGNING_SECRET\u0026#34;], token=os.environ[\u0026#34;SLACK_BOT_TOKEN\u0026#34;] ) @app.command(\u0026#34;/echo\u0026#34;) def echo(ack, respond): ack() respond(\u0026#34;echo\u0026#34;) @app.command(\u0026#34;/hoge\u0026#34;) def hoge(ack, respond): ack() respond(\u0026#34;hoge\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: app.start(port=3000) 実行コマンドは次のとおり:\n1 2 3 4 $ docker-compose build $ docker-compose up -d $ docker exec -it \u0026lt;CONTAINER_ID\u0026gt; bash [IN CONTAINER]# python main.py Slack App 設定 App 作成 まずは普通に Slack App を作成。 App Display Name 、 Default username がデフォルトだと空欄になっており、これらを設定しないとワークスペースへインストールできないので、忘れず設定すること。\n参考:\n【Slack】インストールするボットユーザーがありませんと出たときの対処方法 | THE SIMPLE Slash Commands 1 2 3 4 5 6 7 8 9 slash_commands: - command: /echo url: https://xxxxxxxxxx.ngrok-free.app/slack/events description: echo should_escape: false - command: /hoge url: https://xxxxxxxxxx.ngrok-free.app/slack/events description: hoge should_escape: false ⚠️ url のエンドポイントは /echo や /hoge ではなく一律 /slack/events （ここで無駄に時間を溶かしてしまった…）\n参考: コマンドのリスニングと応答 - Slack | Bolt for Python\nOAuth \u0026amp; Permissions 実際に動かしてみる 入力 実行結果 ","date":"2023-11-25T17:45:00Z","permalink":"https://yamamoto-yuta.github.io/tmp-hugo-test/p/slack-slash-commands-notes/","title":"Slack の Slash Commands 作成メモ"},{"content":"Function Calling が説明等を読んでもイマイチよくわからなかったので実際に試してみた。これはその時のメモ。\n今回は次の公式ドキュメントの手順をやってみた。\nhttps://platform.openai.com/docs/guides/function-calling\nまた、次の日本語解説記事が参考になった。\nhttps://dev.classmethod.jp/articles/understand-openai-function-calling/\nセットアップ 今回、実行環境は Google Colab にした。\nまずは OpenAI ライブラリをインストール。\n1 !pip install openai 続いて、各種ライブラリのインポートと OpenAI クライアントを作成。\n1 2 3 4 5 6 import json from openai import OpenAI client = OpenAI( api_key=OPENAI_API_KEY ) OpenAI API Key は次のページで作成できる:\nAPI keys - OpenAI API\n今回、 Function Calling の動作確認用に次のダミー関数を利用した。\n1 2 3 4 5 6 7 8 9 10 11 12 # Example dummy function hard coded to return the same weather # In production, this could be your backend API or an external API def get_current_weather(location, unit=\u0026#34;fahrenheit\u0026#34;): \u0026#34;\u0026#34;\u0026#34;Get the current weather in a given location\u0026#34;\u0026#34;\u0026#34; if \u0026#34;tokyo\u0026#34; in location.lower(): return json.dumps({\u0026#34;location\u0026#34;: \u0026#34;Tokyo\u0026#34;, \u0026#34;temperature\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}) elif \u0026#34;san francisco\u0026#34; in location.lower(): return json.dumps({\u0026#34;location\u0026#34;: \u0026#34;San Francisco\u0026#34;, \u0026#34;temperature\u0026#34;: \u0026#34;72\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;fahrenheit\u0026#34;}) elif \u0026#34;paris\u0026#34; in location.lower(): return json.dumps({\u0026#34;location\u0026#34;: \u0026#34;Paris\u0026#34;, \u0026#34;temperature\u0026#34;: \u0026#34;22\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}) else: return json.dumps({\u0026#34;location\u0026#34;: location, \u0026#34;temperature\u0026#34;: \u0026#34;unknown\u0026#34;}) 全体像 公式ドキュメントのコードの全体像は次のとおり:\n（AI が）質問に必要な関数を選び、引数を作成する （プログラムが）関数を実行 （AI が）関数結果も入力に入れて質問に回答する 引用: [OpenAI] Function calling で遊んでみたら本質が見えてきたのでまとめてみた | DevelopersIO\nSTEP 1 ｜会話と利用可能な関数をモデルに送る 公式ドキュメントのコード（日本語のコメントは自分で追記した）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # Step 1: send the conversation and available functions to the model # 会話 messages = [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;What\u0026#39;s the weather like in San Francisco, Tokyo, and Paris?\u0026#34;}] # 利用可能な関数 tools = [ { \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34;, \u0026#34;function\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;get_current_weather\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Get the current weather in a given location\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;location\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The city and state, e.g. San Francisco, CA\u0026#34;, }, \u0026#34;unit\u0026#34;: {\u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;enum\u0026#34;: [\u0026#34;celsius\u0026#34;, \u0026#34;fahrenheit\u0026#34;]}, }, \u0026#34;required\u0026#34;: [\u0026#34;location\u0026#34;], }, }, } ] # モデルへ投げて回答を取得 response = client.chat.completions.create( model=\u0026#34;gpt-3.5-turbo-1106\u0026#34;, messages=messages, tools=tools, tool_choice=\u0026#34;auto\u0026#34;, # auto is default, but we\u0026#39;ll be explicit ) response の中身はこんな感じ。今回はサンフランシスコ、東京、パリの 3 つの都市の天気を訊いているので、 tool_calls が 3 リクエスト分になっている。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 { \u0026#39;id\u0026#39;: \u0026#39;chatcmpl-xxxxxxxxxx\u0026#39;, \u0026#39;choices\u0026#39;: [ Choice( finish_reason=\u0026#39;tool_calls\u0026#39;, index=0, message=ChatCompletionMessage( content=None, role=\u0026#39;assistant\u0026#39;, function_call=None, tool_calls=[ ChatCompletionMessageToolCall( id=\u0026#39;call_aaaaaaaaaa\u0026#39;, function=Function( arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;San Francisco\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39; ), type=\u0026#39;function\u0026#39; ), ChatCompletionMessageToolCall( id=\u0026#39;call_bbbbbbbbbb\u0026#39;, function=Function( arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Tokyo\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39; ), type=\u0026#39;function\u0026#39; ), ChatCompletionMessageToolCall( id=\u0026#39;call_cccccccccc\u0026#39;, function=Function( arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Paris\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39; ), type=\u0026#39;function\u0026#39; ) ] ) ) ], \u0026#39;created\u0026#39;: 1700895213, \u0026#39;model\u0026#39;: \u0026#39;gpt-3.5-turbo-1106\u0026#39;, \u0026#39;object\u0026#39;: \u0026#39;chat.completion\u0026#39;, \u0026#39;system_fingerprint\u0026#39;: \u0026#39;fp_xxxxxxxxxx\u0026#39;, \u0026#39;usage\u0026#39;: CompletionUsage( completion_tokens=77, prompt_tokens=88, total_tokens=165 ) } この中から次の 2 つを取り出す。\n1 2 response_message = response.choices[0].message tool_calls = response_message.tool_calls 次の処理に入る前に、 Function Calling が要求されているかのチェックが必要。\n1 2 3 # Step 2: check if the model wanted to call a function if tool_calls: ... STEP 2 ｜実際に関数を実行する 公式ドキュメント:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Step 3: call the function # Note: the JSON response may not always be valid; be sure to handle errors available_functions = { \u0026#34;get_current_weather\u0026#34;: get_current_weather, } # only one function in this example, but you can have multiple messages.append(response_message) # extend conversation with assistant\u0026#39;s reply # Step 4: send the info for each function call and function response to the model for tool_call in tool_calls: function_name = tool_call.function.name function_to_call = available_functions[function_name] function_args = json.loads(tool_call.function.arguments) function_response = function_to_call( location=function_args.get(\u0026#34;location\u0026#34;), unit=function_args.get(\u0026#34;unit\u0026#34;), ) messages.append( { \u0026#34;tool_call_id\u0026#34;: tool_call.id, \u0026#34;role\u0026#34;: \u0026#34;tool\u0026#34;, \u0026#34;name\u0026#34;: function_name, \u0026#34;content\u0026#34;: function_response, } ) # extend conversation with function response 分解して見ていく。\n利用可能な関数の辞書を作成している。今回は get_current_weather() しか利用できないので、辞書内のアイテムは 1 つだけになる。\n1 2 3 available_functions = { \u0026#34;get_current_weather\u0026#34;: get_current_weather, } # only one function in this example, but you can have multiple available_functions の中身は次のようになっている。関数がオブジェクトとして辞書に登録されている。\n1 {\u0026#39;get_current_weather\u0026#39;: \u0026lt;function __main__.get_current_weather(location, unit=\u0026#39;fahrenheit\u0026#39;)\u0026gt;} STEP 1 で得た response_message を message に append している。これは STEP 3 で最終的な回答を作成するために使用する。\n1 messages.append(response_message) # extend conversation with assistant\u0026#39;s reply したがって、 messages の中身は次のようになる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [ { \u0026#39;role\u0026#39;: \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;: \u0026#34;What\u0026#39;s the weather like in San Francisco, Tokyo, and Paris?\u0026#34; }, ChatCompletionMessage( content=None, role=\u0026#39;assistant\u0026#39;, function_call=None, tool_calls=[ ChatCompletionMessageToolCall( id=\u0026#39;call_aaaaaaaaaa\u0026#39;, function=Function( arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;San Francisco\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39; ), type=\u0026#39;function\u0026#39; ), ChatCompletionMessageToolCall( id=\u0026#39;call_bbbbbbbbbb\u0026#39;, function=Function( arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Tokyo\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39; ), type=\u0026#39;function\u0026#39; ), ChatCompletionMessageToolCall( id=\u0026#39;call_cccccccccc\u0026#39;, function=Function( arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Paris\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39; ), type=\u0026#39;function\u0026#39; ) ] ) ] STEP 1 で作成したリクエストをループで順次、実際に関数へリクエストしていく。\n1 2 3 # Step 4: send the info for each function call and function response to the model for tool_call in tool_calls: ... 実際に関数を実行する部分は次のコード。\n1 2 3 4 5 6 7 8 9 10 11 12 # 呼び出す関数を取得 function_name = tool_call.function.name function_to_call = available_functions[function_name] # 関数に渡す引数を取得（引数は JSON 文字列で格納されているので json.loads() ） function_args = json.loads(tool_call.function.arguments) # 実際に関数を実行する function_response = function_to_call( location=function_args.get(\u0026#34;location\u0026#34;), unit=function_args.get(\u0026#34;unit\u0026#34;), ) 関数の実行結果を messages へ append している。これは STEP 3 で最終的な回答を作成するためである。\n1 2 3 4 5 6 7 8 messages.append( { \u0026#34;tool_call_id\u0026#34;: tool_call.id, \u0026#34;role\u0026#34;: \u0026#34;tool\u0026#34;, \u0026#34;name\u0026#34;: function_name, \u0026#34;content\u0026#34;: function_response, } ) # extend conversation with function response ループ終了時の messages の中身は次のようになっている。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [{\u0026#39;role\u0026#39;: \u0026#39;user\u0026#39;, \u0026#39;content\u0026#39;: \u0026#34;What\u0026#39;s the weather like in San Francisco, Tokyo, and Paris?\u0026#34;}, ChatCompletionMessage(content=None, role=\u0026#39;assistant\u0026#39;, function_call=None, tool_calls=[ChatCompletionMessageToolCall(id=\u0026#39;call_aaaaaaaaaa\u0026#39;, function=Function(arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;San Francisco\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39;), type=\u0026#39;function\u0026#39;), ChatCompletionMessageToolCall(id=\u0026#39;call_bbbbbbbbbb\u0026#39;, function=Function(arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Tokyo\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39;), type=\u0026#39;function\u0026#39;), ChatCompletionMessageToolCall(id=\u0026#39;call_cccccccccc\u0026#39;, function=Function(arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Paris\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39;), type=\u0026#39;function\u0026#39;)]), {\u0026#39;tool_call_id\u0026#39;: \u0026#39;call_aaaaaaaaaa\u0026#39;, \u0026#39;role\u0026#39;: \u0026#39;tool\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;get_current_weather\u0026#39;, \u0026#39;content\u0026#39;: \u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;San Francisco\u0026#34;, \u0026#34;temperature\u0026#34;: \u0026#34;72\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;fahrenheit\u0026#34;}\u0026#39;}, {\u0026#39;tool_call_id\u0026#39;: \u0026#39;call_bbbbbbbbbb\u0026#39;, \u0026#39;role\u0026#39;: \u0026#39;tool\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;get_current_weather\u0026#39;, \u0026#39;content\u0026#39;: \u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Tokyo\u0026#34;, \u0026#34;temperature\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;}, {\u0026#39;tool_call_id\u0026#39;: \u0026#39;call_cccccccccc\u0026#39;, \u0026#39;role\u0026#39;: \u0026#39;tool\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;get_current_weather\u0026#39;, \u0026#39;content\u0026#39;: \u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Paris\u0026#34;, \u0026#34;temperature\u0026#34;: \u0026#34;22\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;}] STEP 3 ｜最終的な回答を作成する 公式ドキュメントのコード:\n1 2 3 4 second_response = client.chat.completions.create( model=\u0026#34;gpt-3.5-turbo-1106\u0026#34;, messages=messages, ) # get a new response from the model where it can see the function response second_response の中身:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \u0026#39;id\u0026#39;: \u0026#39;chatcmpl-yyyyyyyyyy\u0026#39;, \u0026#39;choices\u0026#39;: [ Choice( finish_reason=\u0026#39;stop\u0026#39;, index=0, message=ChatCompletionMessage( content=\u0026#39;Currently, the weather in San Francisco is 72°F, in Tokyo it is 10°C, and in Paris it is 22°C.\u0026#39;, role=\u0026#39;assistant\u0026#39;, function_call=None, tool_calls=None ) ) ], \u0026#39;created\u0026#39;: 1700895214, \u0026#39;model\u0026#39;: \u0026#39;gpt-3.5-turbo-1106\u0026#39;, \u0026#39;object\u0026#39;: \u0026#39;chat.completion\u0026#39;, \u0026#39;system_fingerprint\u0026#39;: \u0026#39;fp_eeff13170a\u0026#39;, \u0026#39;usage\u0026#39;: CompletionUsage( completion_tokens=29, prompt_tokens=169, total_tokens=198 ) } second_response.choices[0].message.content を見てみると、関数の実行結果が回答に組み込まれていることがわかる。\n1 \u0026#39;Currently, the weather in San Francisco is 72°F, in Tokyo it is 10°C, and in Paris it is 22°C.\u0026#39; 何が嬉しいのか？ （ほぼほぼ「 [OpenAI] Function calling で遊んでみたら本質が見えてきたのでまとめてみた | DevelopersIO 」に書かれていることではあるが…）\n例えば、今回のように自然言語で各都市の気温を問い合わせる仕組みを作る場合、 ChatGPT だけでは各都市の気温は答えられないので API 等で別途情報を取得してくる必要がある（補足）。そのため、問い合わせ文から API 等へのリクエストに必要な情報を抽出する必要があった。\n「 What\u0026rsquo;s the weather like in San Francisco, Tokyo, and Paris? 」という質問の場合、（どのような情報がリクエストに必要かによるが）「 San Francisco 」「 Tokyo 」「 Paris 」の 3 つの情報を抽出する必要がある。\nFunction Calling が登場するまでは、プロンプトを工夫することで情報を抽出しやすくしていた。\n例えば次のプロンプトを用いたとする。\n1 2 3 4 5 6 7 8 次の問い合わせ文から都市を抽出してください。出力フォーマットは次のようにしてください: ## 出力フォーマット - 都市1 - 都市2 ## 問い合わせ文 What\u0026#39;s the weather like in San Francisco, Tokyo, and Paris? すると、 ChatGPT は次のように回答してくれる。\n1 2 3 4 ## 出力フォーマット - San Francisco - Tokyo - Paris 今回の気温の例は出力フォーマットがシンプルだったので比較的指定したフォーマットで回答してくれているが、複雑な出力フォーマットだったりすると指定したフォーマットにしたがってくれなかったりする。\nFunction Calling を使えば、引数の仕様を指定すればそれに合うように情報を抽出してくれる。例えば今回の場合、次のように情報を抽出してくれていた。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [ ChatCompletionMessageToolCall( id=\u0026#39;call_aaaaaaaaaa\u0026#39;, function=Function( arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;San Francisco\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39; ), type=\u0026#39;function\u0026#39; ), ChatCompletionMessageToolCall( id=\u0026#39;call_bbbbbbbbbb\u0026#39;, function=Function( arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Tokyo\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39; ), type=\u0026#39;function\u0026#39; ), ChatCompletionMessageToolCall( id=\u0026#39;call_cccccccccc\u0026#39;, function=Function( arguments=\u0026#39;{\u0026#34;location\u0026#34;: \u0026#34;Paris\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;celsius\u0026#34;}\u0026#39;, name=\u0026#39;get_current_weather\u0026#39; ), type=\u0026#39;function\u0026#39; ) ] 補足: 今は Browse with Bing のおかげで ChatGPT 単体での回答が可能になっている 現在では ChatGPT に「 Browse with Bing 」機能が搭載されているため、 LLM 単体でも回答が可能となっている。\n例えば、今回の「 What\u0026rsquo;s the weather like in San Francisco, Tokyo, and Paris? 」という質問を ChatGPT (ChatGPT Plus 加入版) に投げてみたところ、次の回答が得られた:\n現在の天気について、以下の都市の情報は次の通りです：\nサンフランシスコ（カリフォルニア州、アメリカ）：気温は 57°F（約 14°C）で、部分的に雲があります。今後の予報では最高気温が 66°F（約 19°C）、最低気温が 49°F（約 9°C）となる見込みです。風速は北東から 5mph（約 8km/h）です[”]。\n東京（日本）：気温は 60°F（約 16°C）で、涼しいです。今後の予報では最高気温が 76°F（約 24°C）、最低気温が 48°F（約 9°C）となる見込みです。風速は南から 9mph（約 14km/h）です[”]。\nパリ（フランス）：気温は 41°F（約 5°C）で、一部に雲があります。体感温度は 39°F（約 4°C）です。今後の予報では最高気温が 56°F（約 13°C）、最低気温が 40°F（約 4°C）となる見込みです。風速は北西から 3mph（約 5km/h）です[”]。\nこれらの情報は、各都市の現在の気象条件を反映しています。天候は変わりやすいので、最新の情報を得るためには、定期的に天気予報を確認することをお勧めします。\n","date":"2023-11-25T11:54:00Z","permalink":"https://yamamoto-yuta.github.io/tmp-hugo-test/p/function-calling-memo/","title":"Function Calling 触ってみたメモ"},{"content":"先日、ブラウザ拡張機能「 CSV2MD Shortcut 」の v0.2.0 をリリースした 。このバージョンでは新機能として Popup からテキスト変換を行えるようにした。 v0.1.0 では BSW にテキスト変換処理を実装していた。 Popup からテキスト変換を行えるようにするにあたってその処理を BSW から切り出そうとした。が、うまくいかなかった…。 この記事では、そのときの試行錯誤をログとして残す。 該当 issue:\nhttps://github.com/yamamoto-yuta/csv2md-shortcut/issues/35\n検証用リポジトリ:\nhttps://github.com/yamamoto-yuta/chrome-extension-injected-code-debug\n公式ドキュメントの記載:\nFor the func key, you can pass in a TS function from your project. It will be transpiled into JS when your extension bundles. You may also use the files key to inject a file from the root of the built bundle.\nこれを読む限り、ビルド済みファイルに手を加えるしか無さそう…？（であれば、それは管理面倒くさくなりそうなのでやらない方が良さそう…）\n","date":"2023-08-05T15:57:00Z","permalink":"https://yamamoto-yuta.github.io/tmp-hugo-test/p/executing-functions-from-other-files-in-executescript/","title":"executeScript() で呼ぶ関数の中で別ファイルの関数を呼び出したい"},{"content":"2024/06/30 に v1.0.0 がリリースされたので、以後は README の手順で OK。\nhttps://github.com/ShotaroKataoka/ls-Improved\n2024/06/29以前の方法 コードはここ https://github.com/ShotaroKataoka/ls-Improved/tree/develop-rust-rewrite\nManual 公式 GitHub の Releases ページからダウンロード ダウンロードファイルを解凍して、lsi を使いたいディレクトリへ移動 path/to/lsi-** で動く 毎回 path/to/lsi-** と打つのは面倒くさいので alias を登録しておくと良い。\napt 手順 PPA リポジトリ:\nhttps://github.com/ShotaroKataoka/ppa\nGPG 鍵をダウンロード 1 curl -s --compressed \u0026#34;https://ShotaroKataoka.github.io/ppa/ubuntu/KEY.gpg\u0026#34; | gpg --dearmor | tee /etc/apt/trusted.gpg.d/ls_improved_ppa.gpg PPA を追加 1 echo \u0026#34;deb [signed-by=/etc/apt/trusted.gpg.d/ls_improved_ppa.gpg] https://ShotaroKataoka.github.io/ppa/ubuntu ./\u0026#34; | tee /etc/apt/sources.list.d/ls_Improved.list インストール 1 apt-get update \u0026amp;\u0026amp; apt-get install ls-improved 検証用環境 Dockerfile:\n1 2 3 4 5 FROM ubuntu:20.04 RUN apt-get update \u0026amp;\u0026amp; apt-get upgrade -y \u0026amp;\u0026amp; apt-get install -y \\ curl \\ gpg docker-compose.yml\n1 2 3 4 5 6 7 version: \u0026#34;3.8\u0026#34; services: ubuntu: build: . image: ubuntu-apt-install-sandbox container_name: ubuntu tty: true 参考記事 .deb ファイルをカスタマイズして、GitHub で PPA をホストして、Debian にインストールする方法（その 4: ホスティングした PPA から、パッケージを Debian にインストールする）｜ Ryo Nakano gcloud CLI をインストールする | Google Cloud ","date":"2023-07-23T14:50:00Z","permalink":"https://yamamoto-yuta.github.io/tmp-hugo-test/p/rust-ls-improved-installation-notes/","title":"Rust 版 ls-Improved 導入メモ"},{"content":"前から気になっていたブラウザ拡張機能の開発フレームワーク「Plasmo」を触ってみたので、その時のメモ。\n基本的に下記の記事をなぞる形で触っていった。\nブラウザ拡張機能を作るための React フレームワーク『Plasmo』\nなので、ここでは上記記事をなぞった際につまづいた箇所や個人的な所感などについて記す。\n環境構築を Docker でやってみた ローカル環境がごちゃごちゃするのが個人的に嫌だったので、 Docker で環境構築してみた。\n上記記事や公式ドキュメントには特に Docker についての言及は無かったが、 Node.js があれば十分だったので適当な Node.js のイメージを持ってこればいけるはず。\nちなみに、 Plasmo のシステム要件として Node.js が 16.14 以降であることが挙げられていた。\nNode.js 16.14.x or later\n引用: https://docs.plasmo.com/framework#system-requirements\nただ、 Node.js のリリースケジュールによると 16 系は今年（記事執筆時は 2023 年 6 月 4 日）の 9 月で End-of-life とのことだったので、今回は 18 系を使ってみることにした。\nNode.js のリリーススケジュール:\nhttps://github.com/nodejs/Release#release-schedule\n以上を踏まえて作成した docker-compose.yml が下記の通り:\n1 2 3 4 5 6 7 8 9 version: \u0026#34;3\u0026#34; services: app: image: node:18.16.0 volumes: - .:/usr/src/app working_dir: /usr/src/app tty: true Plasmo プロジェクトの作成は docker compose run コマンドを用いて下記で行える。なお、 Plasmo は pnpm コマンドの利用を推奨していたが、 Node.js のイメージにデフォルトで入っていなかったので今回はデフォルトで入っている npm コマンドで進めた。コマンド実行のためにコンテナが溜まっていかないよう --rm オプションを付けている。\n1 $ docker compose run --rm app npm create plasmo プロジェクト作成の際に色々訊かれたが、今回は拡張機能の名前を learn-plasmo にした以外は既定値で回答した。\nDevelopment server の起動も同様に下記のコマンドで行える。プロジェクトディレクトリ（ learn-plasmo/ ）に移動する必要がある点に注意。\n1 $ docker compose run --rm app bash -c \u0026#34;cd learn-plasmo \u0026amp;\u0026amp; npm run dev\u0026#34; 記事中に Storage API を利用するためにパッケージを追加インストールするくだりがあるが、それも下記コマンドで行える:\n1 $ docker compose run --rm app bash -c \u0026#34;cd learn-plasmo \u0026amp;\u0026amp; npm install @plasmohq/storage react-hook-form\u0026#34; 他にも Messaging API を利用するためにも追加インストールのくだりがあったが、それも下記コマンドで行える:\n1 $ docker compose run --rm app bash -c \u0026#34;cd learn-plasmo \u0026amp;\u0026amp; npm install @plasmohq/messaging\u0026#34; つまづいた点メモ 「 Storage を利用する 」のところでなぜか入力値が保存されなくてつまづいたが、一度 Production build で動かした後 Development server に戻ってきたらちゃんと保存されるようになった。原因は不明…（要検証） 「 New Tab Page 」のところは自分が Vivaldi ユーザだったせいでそもそもカスタマイズできなかった ファイル変更時は「ホットリロードが走る → 拡張機能を再読み込み」の手順を踏むと反映される 個人的な所感 デフォルトで下記の機能が付いてるのが良かった:\ndev/prod のビルド分け ホットリロード また、今回は試さなかったが下記の機能も良さそうだった:\nChrome Web Store への自動デプロイ Google Analytics と連携できるっぽい（→ 公式ドキュメント ） メンテナンスもこまめにされてそうなので、これから拡張機能作るときは Plasmo 使うようにしてみようかな…\n","date":"2023-06-04T12:54:00Z","permalink":"https://yamamoto-yuta.github.io/tmp-hugo-test/p/memo-on-trying-plasmo/","title":"Plasmo 触ってみたメモ"},{"content":"いつも使ってる Slack 向け絵文字ジェネレーター:\n絵文字ジェネレーター - Slack 向け絵文字を無料で簡単生成\nリポジトリを見てみるとバックエンドに Python を用いており、その中で emojilib という自作ライブラリを用いていることが分かった。\nそこで emojilib のリポジトリを見てみると、 emojilib は libemoji という C/C++ 製の自作ライブラリの Python ラッパーということが分かった。\nemojilib を動かせるようにした Dockerfile を下記に示す。 emojilib 自体は pip install でインストールできるのだが、 libemoji を動かすため依存が いくつかあった ので別途 apt-get install で入れている。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 FROM python:3.7 RUN apt-get update \u0026amp;\u0026amp; apt-get upgrade -y RUN apt-get install -y \\ git \\ cmake \\ g++ \\ libfontconfig1-dev \\ libx11-dev \\ libxcomposite-dev \\ libgl1-mesa-dev \\ libglu1-mesa-dev \\ freeglut3-dev RUN pip install --upgrade pip RUN pip install emojilib --extra-index-url https://repo.fury.io/emoji-gen/ ","date":"2023-05-07T16:08:00Z","permalink":"https://yamamoto-yuta.github.io/tmp-hugo-test/p/how-slack-emoji-generator-works/","title":"いつも使ってるSlack向け絵文字ジェネレーターがどうやって絵文字を生成してるか調べてみたメモ"},{"content":"やりたいこと Slack API 経由で Slack へ絵文字を追加したい\n調べたこと 方針 1: Slack API の admin.emoji.add を利用する 公式で用意されている絵文字追加用 API。\n公式ドキュメント: https://api.slack.com/methods/admin.emoji.add\nただし、結局この API は使えなかった。理由はこの API を利用するには Slack App に admin.teams:write という権限を付与する必要があったから。\nadmin.teams:write についての公式ドキュメント: https://api.slack.com/scopes/admin.teams:write\nこれには次の問題があったので今回は方針を変更することにした:\nAdmin API は個々のワークスペースではなく組織全体に影響を与えることができ、ただ絵文字を追加するだけの用途で付与するには不適当なため そもそも Enterprise 版でないと利用できないため 方針 2: 一般公開されていない API /api/emoji.add を利用する どうやら Slack には一般公開されていない API がいくつかあるらしく、その中の一つである /api/emoji.add を利用すれば絵文字の追加が可能らしい:\n参考: https://github.com/slackhq/slack-api-docs/issues/28#issuecomment-424195796\nこの API を利用しているプロダクトがいくつかあるようだったので、それらを参考に API を叩いてみた。 API を叩く手順は次の通り。\n/api/emoji.add API を叩く手順 1. トークンを入手する 絵文字を追加したいワークスペースを開く 開発者ツールを開き、コンソールタブで次のコマンドを実行する 1 2 3 JSON.parse(localStorage.localConfig_v2).teams[ document.location.pathname.match(/^\\/client\\/(T[A-Z0-9]+)/)[1] ].token; 引用: https://github.com/jackellenberger/emojme/blob/master/README.md#cookie-token-one-liner\nxoxc-xxxxxxxxxx といった形式のトークンが返ってくるはず。\n2. Cookie を入手する https://\u0026lt;TEAM_ID\u0026gt;.slack.com/customize/emoji を開く（ワークスペースを開いた状態で「以下をカスタマイズ」をクリックすると飛べる） 開発者ツールを開き、「ネットワーク」タブを開く emoji というドキュメントを選択する リクエストヘッダーの cookie: の値が入手したい Cookie （この値をコピーするとき、「右クリック \u0026gt; 『値をコピー』」だとコピー後の文字列に日本語が混じって後で困るので、範囲選択でコピーする必要がある） 3. API を叩く API を叩くコード:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import requests TOKEN = \u0026#34;xoxc-xxxxxxxxxx\u0026#34; # トークン COOKIE = \u0026#34;xxxxxxxxxx\u0026#34; # Cookie team_name = \u0026#34;xxxxxxxxxx\u0026#34; # ワークスペースのチーム名 emoji_name = \u0026#34;emoji\u0026#34; # 絵文字の名前 emoji_img_filepath = \u0026#34;./emoji.png\u0026#34; # 絵文字の画像ファイルへのパス URL_ADD = \u0026#34;https://{team_name}.slack.com/api/emoji.add\u0026#34; r = requests.post( URL_ADD.format(team_name=team_name), headers = {\u0026#39;Cookie\u0026#39;: COOKIE}, data = { \u0026#39;mode\u0026#39;: \u0026#39;data\u0026#39;, \u0026#39;name\u0026#39;: emoji_name, \u0026#39;token\u0026#39;: TOKEN }, files={\u0026#39;image\u0026#39;: open(emoji_img_filepath, \u0026#39;rb\u0026#39;)} ) 次のレスポンスが返ってきていれば成功:\n1 {\u0026#34;ok\u0026#34;:true} 残る課題 トークンと Cookie の入手を自動でできないか？ 余談 /api/emoji.add の xoxb トークンでの利用について /api/emoji.add を xoxb トークンで利用できるよう求める Issue が 2019 年 1 月に建てられているが、2023 年 5 月現在、まだ Open なままである。\n該当 Issue: https://github.com/slackhq/slack-api-docs/issues/95\nxoxc トークンをスクレイピングで入手する https://\u0026lt;TEAM_ID\u0026gt;.slack.com/customize/emoji ページをスクレイピングすることで xoxc トークンを入手している例を紹介している 記事 を見つけた。\n該当コード: https://github.com/smashwilson/slack-emojinator/blob/fbcf759ebbda8bd37b77c91362edde9fd3e0c05a/upload.py#L81-L94\nしかし、やってみたがうまくいかなかった（ api_token: の値が \u0026quot;\u0026quot; だった）。やってみた当時はまだトークンや Cookie の入手などが手探りの状態だったので、それが原因でうまくいかなかったのかも…？\n参考 Slack で絵文字を追加するサービスを作ろうとしたときに調べたこと Slack Custom Emoji を追加する非公開 API /api/emoji.add | CodeNote smashwilson/slack-emojinator: Bulk upload emoji into Slack Fauntleroy/neutral-face-emoji-tools: Utilities that make life as a Slack emoji addict a little easier. jackellenberger/emojme: very powerful very stupid Slack emoji tools, holy cow! ","date":"2023-05-06T16:56:00Z","permalink":"https://yamamoto-yuta.github.io/tmp-hugo-test/p/api-add-custom-emoji-to-slack/","title":"API経由でSlackへカスタム絵文字を追加できないか調査したときのメモ"}]